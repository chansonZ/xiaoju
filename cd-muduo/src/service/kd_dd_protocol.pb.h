// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kd_dd_protocol.proto

#ifndef PROTOBUF_kd_5fdd_5fprotocol_2eproto__INCLUDED
#define PROTOBUF_kd_5fdd_5fprotocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace DdKd {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_kd_5fdd_5fprotocol_2eproto();
void protobuf_AssignDesc_kd_5fdd_5fprotocol_2eproto();
void protobuf_ShutdownFile_kd_5fdd_5fprotocol_2eproto();

class UserAgent;
class Header;
class KDLocationInfo;

enum KDLocationInfo_WorkState {
  KDLocationInfo_WorkState_WORK = 1,
  KDLocationInfo_WorkState_OFFWORK = 2
};
bool KDLocationInfo_WorkState_IsValid(int value);
const KDLocationInfo_WorkState KDLocationInfo_WorkState_WorkState_MIN = KDLocationInfo_WorkState_WORK;
const KDLocationInfo_WorkState KDLocationInfo_WorkState_WorkState_MAX = KDLocationInfo_WorkState_OFFWORK;
const int KDLocationInfo_WorkState_WorkState_ARRAYSIZE = KDLocationInfo_WorkState_WorkState_MAX + 1;

const ::google::protobuf::EnumDescriptor* KDLocationInfo_WorkState_descriptor();
inline const ::std::string& KDLocationInfo_WorkState_Name(KDLocationInfo_WorkState value) {
  return ::google::protobuf::internal::NameOfEnum(
    KDLocationInfo_WorkState_descriptor(), value);
}
inline bool KDLocationInfo_WorkState_Parse(
    const ::std::string& name, KDLocationInfo_WorkState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<KDLocationInfo_WorkState>(
    KDLocationInfo_WorkState_descriptor(), name, value);
}
enum Constants {
  kMagic = 22613
};
bool Constants_IsValid(int value);
const Constants Constants_MIN = kMagic;
const Constants Constants_MAX = kMagic;
const int Constants_ARRAYSIZE = Constants_MAX + 1;

const ::google::protobuf::EnumDescriptor* Constants_descriptor();
inline const ::std::string& Constants_Name(Constants value) {
  return ::google::protobuf::internal::NameOfEnum(
    Constants_descriptor(), value);
}
inline bool Constants_Parse(
    const ::std::string& name, Constants* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Constants>(
    Constants_descriptor(), name, value);
}
enum KDMsgType {
  KDMsgTypeLocPoint = 1
};
bool KDMsgType_IsValid(int value);
const KDMsgType KDMsgType_MIN = KDMsgTypeLocPoint;
const KDMsgType KDMsgType_MAX = KDMsgTypeLocPoint;
const int KDMsgType_ARRAYSIZE = KDMsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* KDMsgType_descriptor();
inline const ::std::string& KDMsgType_Name(KDMsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    KDMsgType_descriptor(), value);
}
inline bool KDMsgType_Parse(
    const ::std::string& name, KDMsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<KDMsgType>(
    KDMsgType_descriptor(), name, value);
}
// ===================================================================

class UserAgent : public ::google::protobuf::Message {
 public:
  UserAgent();
  virtual ~UserAgent();

  UserAgent(const UserAgent& from);

  inline UserAgent& operator=(const UserAgent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserAgent& default_instance();

  void Swap(UserAgent* other);

  // implements Message ----------------------------------------------

  UserAgent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserAgent& from);
  void MergeFrom(const UserAgent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string os_type = 1;
  inline bool has_os_type() const;
  inline void clear_os_type();
  static const int kOsTypeFieldNumber = 1;
  inline const ::std::string& os_type() const;
  inline void set_os_type(const ::std::string& value);
  inline void set_os_type(const char* value);
  inline void set_os_type(const char* value, size_t size);
  inline ::std::string* mutable_os_type();
  inline ::std::string* release_os_type();
  inline void set_allocated_os_type(::std::string* os_type);

  // optional string os_ver = 2;
  inline bool has_os_ver() const;
  inline void clear_os_ver();
  static const int kOsVerFieldNumber = 2;
  inline const ::std::string& os_ver() const;
  inline void set_os_ver(const ::std::string& value);
  inline void set_os_ver(const char* value);
  inline void set_os_ver(const char* value, size_t size);
  inline ::std::string* mutable_os_ver();
  inline ::std::string* release_os_ver();
  inline void set_allocated_os_ver(::std::string* os_ver);

  // optional string model = 3;
  inline bool has_model() const;
  inline void clear_model();
  static const int kModelFieldNumber = 3;
  inline const ::std::string& model() const;
  inline void set_model(const ::std::string& value);
  inline void set_model(const char* value);
  inline void set_model(const char* value, size_t size);
  inline ::std::string* mutable_model();
  inline ::std::string* release_model();
  inline void set_allocated_model(::std::string* model);

  // optional string client_ver = 4;
  inline bool has_client_ver() const;
  inline void clear_client_ver();
  static const int kClientVerFieldNumber = 4;
  inline const ::std::string& client_ver() const;
  inline void set_client_ver(const ::std::string& value);
  inline void set_client_ver(const char* value);
  inline void set_client_ver(const char* value, size_t size);
  inline ::std::string* mutable_client_ver();
  inline ::std::string* release_client_ver();
  inline void set_allocated_client_ver(::std::string* client_ver);

  // optional string network = 5;
  inline bool has_network() const;
  inline void clear_network();
  static const int kNetworkFieldNumber = 5;
  inline const ::std::string& network() const;
  inline void set_network(const ::std::string& value);
  inline void set_network(const char* value);
  inline void set_network(const char* value, size_t size);
  inline ::std::string* mutable_network();
  inline ::std::string* release_network();
  inline void set_allocated_network(::std::string* network);

  // optional string location = 6;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 6;
  inline const ::std::string& location() const;
  inline void set_location(const ::std::string& value);
  inline void set_location(const char* value);
  inline void set_location(const char* value, size_t size);
  inline ::std::string* mutable_location();
  inline ::std::string* release_location();
  inline void set_allocated_location(::std::string* location);

  // optional string carrier_operator = 7;
  inline bool has_carrier_operator() const;
  inline void clear_carrier_operator();
  static const int kCarrierOperatorFieldNumber = 7;
  inline const ::std::string& carrier_operator() const;
  inline void set_carrier_operator(const ::std::string& value);
  inline void set_carrier_operator(const char* value);
  inline void set_carrier_operator(const char* value, size_t size);
  inline ::std::string* mutable_carrier_operator();
  inline ::std::string* release_carrier_operator();
  inline void set_allocated_carrier_operator(::std::string* carrier_operator);

  // @@protoc_insertion_point(class_scope:DdKd.UserAgent)
 private:
  inline void set_has_os_type();
  inline void clear_has_os_type();
  inline void set_has_os_ver();
  inline void clear_has_os_ver();
  inline void set_has_model();
  inline void clear_has_model();
  inline void set_has_client_ver();
  inline void clear_has_client_ver();
  inline void set_has_network();
  inline void clear_has_network();
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_carrier_operator();
  inline void clear_has_carrier_operator();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* os_type_;
  ::std::string* os_ver_;
  ::std::string* model_;
  ::std::string* client_ver_;
  ::std::string* network_;
  ::std::string* location_;
  ::std::string* carrier_operator_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_kd_5fdd_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_kd_5fdd_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_kd_5fdd_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static UserAgent* default_instance_;
};
// -------------------------------------------------------------------

class Header : public ::google::protobuf::Message {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  void Swap(Header* other);

  // implements Message ----------------------------------------------

  Header* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DdKd.KDMsgType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::DdKd::KDMsgType type() const;
  inline void set_type(::DdKd::KDMsgType value);

  // optional uint64 msg_id = 2;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 2;
  inline ::google::protobuf::uint64 msg_id() const;
  inline void set_msg_id(::google::protobuf::uint64 value);

  // optional uint64 auth_user_id = 3;
  inline bool has_auth_user_id() const;
  inline void clear_auth_user_id();
  static const int kAuthUserIdFieldNumber = 3;
  inline ::google::protobuf::uint64 auth_user_id() const;
  inline void set_auth_user_id(::google::protobuf::uint64 value);

  // optional bytes log_id = 4;
  inline bool has_log_id() const;
  inline void clear_log_id();
  static const int kLogIdFieldNumber = 4;
  inline const ::std::string& log_id() const;
  inline void set_log_id(const ::std::string& value);
  inline void set_log_id(const char* value);
  inline void set_log_id(const void* value, size_t size);
  inline ::std::string* mutable_log_id();
  inline ::std::string* release_log_id();
  inline void set_allocated_log_id(::std::string* log_id);

  // optional .DdKd.UserAgent user_agent = 5;
  inline bool has_user_agent() const;
  inline void clear_user_agent();
  static const int kUserAgentFieldNumber = 5;
  inline const ::DdKd::UserAgent& user_agent() const;
  inline ::DdKd::UserAgent* mutable_user_agent();
  inline ::DdKd::UserAgent* release_user_agent();
  inline void set_allocated_user_agent(::DdKd::UserAgent* user_agent);

  // @@protoc_insertion_point(class_scope:DdKd.Header)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_msg_id();
  inline void clear_has_msg_id();
  inline void set_has_auth_user_id();
  inline void clear_has_auth_user_id();
  inline void set_has_log_id();
  inline void clear_has_log_id();
  inline void set_has_user_agent();
  inline void clear_has_user_agent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 msg_id_;
  ::google::protobuf::uint64 auth_user_id_;
  ::std::string* log_id_;
  ::DdKd::UserAgent* user_agent_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_kd_5fdd_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_kd_5fdd_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_kd_5fdd_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static Header* default_instance_;
};
// -------------------------------------------------------------------

class KDLocationInfo : public ::google::protobuf::Message {
 public:
  KDLocationInfo();
  virtual ~KDLocationInfo();

  KDLocationInfo(const KDLocationInfo& from);

  inline KDLocationInfo& operator=(const KDLocationInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KDLocationInfo& default_instance();

  void Swap(KDLocationInfo* other);

  // implements Message ----------------------------------------------

  KDLocationInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KDLocationInfo& from);
  void MergeFrom(const KDLocationInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef KDLocationInfo_WorkState WorkState;
  static const WorkState WORK = KDLocationInfo_WorkState_WORK;
  static const WorkState OFFWORK = KDLocationInfo_WorkState_OFFWORK;
  static inline bool WorkState_IsValid(int value) {
    return KDLocationInfo_WorkState_IsValid(value);
  }
  static const WorkState WorkState_MIN =
    KDLocationInfo_WorkState_WorkState_MIN;
  static const WorkState WorkState_MAX =
    KDLocationInfo_WorkState_WorkState_MAX;
  static const int WorkState_ARRAYSIZE =
    KDLocationInfo_WorkState_WorkState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  WorkState_descriptor() {
    return KDLocationInfo_WorkState_descriptor();
  }
  static inline const ::std::string& WorkState_Name(WorkState value) {
    return KDLocationInfo_WorkState_Name(value);
  }
  static inline bool WorkState_Parse(const ::std::string& name,
      WorkState* value) {
    return KDLocationInfo_WorkState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required uint64 driverid = 1;
  inline bool has_driverid() const;
  inline void clear_driverid();
  static const int kDriveridFieldNumber = 1;
  inline ::google::protobuf::uint64 driverid() const;
  inline void set_driverid(::google::protobuf::uint64 value);

  // required double lat = 2;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 2;
  inline double lat() const;
  inline void set_lat(double value);

  // required double lng = 3;
  inline bool has_lng() const;
  inline void clear_lng();
  static const int kLngFieldNumber = 3;
  inline double lng() const;
  inline void set_lng(double value);

  // required double spd = 4;
  inline bool has_spd() const;
  inline void clear_spd();
  static const int kSpdFieldNumber = 4;
  inline double spd() const;
  inline void set_spd(double value);

  // required .DdKd.KDLocationInfo.WorkState work = 5;
  inline bool has_work() const;
  inline void clear_work();
  static const int kWorkFieldNumber = 5;
  inline ::DdKd::KDLocationInfo_WorkState work() const;
  inline void set_work(::DdKd::KDLocationInfo_WorkState value);

  // required uint64 location_timestamp = 6;
  inline bool has_location_timestamp() const;
  inline void clear_location_timestamp();
  static const int kLocationTimestampFieldNumber = 6;
  inline ::google::protobuf::uint64 location_timestamp() const;
  inline void set_location_timestamp(::google::protobuf::uint64 value);

  // required uint32 location_type = 7;
  inline bool has_location_type() const;
  inline void clear_location_type();
  static const int kLocationTypeFieldNumber = 7;
  inline ::google::protobuf::uint32 location_type() const;
  inline void set_location_type(::google::protobuf::uint32 value);

  // required double direction = 8;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 8;
  inline double direction() const;
  inline void set_direction(double value);

  // @@protoc_insertion_point(class_scope:DdKd.KDLocationInfo)
 private:
  inline void set_has_driverid();
  inline void clear_has_driverid();
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_lng();
  inline void clear_has_lng();
  inline void set_has_spd();
  inline void clear_has_spd();
  inline void set_has_work();
  inline void clear_has_work();
  inline void set_has_location_timestamp();
  inline void clear_has_location_timestamp();
  inline void set_has_location_type();
  inline void clear_has_location_type();
  inline void set_has_direction();
  inline void clear_has_direction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 driverid_;
  double lat_;
  double lng_;
  double spd_;
  ::google::protobuf::uint64 location_timestamp_;
  int work_;
  ::google::protobuf::uint32 location_type_;
  double direction_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_kd_5fdd_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_kd_5fdd_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_kd_5fdd_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static KDLocationInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// UserAgent

// optional string os_type = 1;
inline bool UserAgent::has_os_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserAgent::set_has_os_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserAgent::clear_has_os_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserAgent::clear_os_type() {
  if (os_type_ != &::google::protobuf::internal::kEmptyString) {
    os_type_->clear();
  }
  clear_has_os_type();
}
inline const ::std::string& UserAgent::os_type() const {
  return *os_type_;
}
inline void UserAgent::set_os_type(const ::std::string& value) {
  set_has_os_type();
  if (os_type_ == &::google::protobuf::internal::kEmptyString) {
    os_type_ = new ::std::string;
  }
  os_type_->assign(value);
}
inline void UserAgent::set_os_type(const char* value) {
  set_has_os_type();
  if (os_type_ == &::google::protobuf::internal::kEmptyString) {
    os_type_ = new ::std::string;
  }
  os_type_->assign(value);
}
inline void UserAgent::set_os_type(const char* value, size_t size) {
  set_has_os_type();
  if (os_type_ == &::google::protobuf::internal::kEmptyString) {
    os_type_ = new ::std::string;
  }
  os_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserAgent::mutable_os_type() {
  set_has_os_type();
  if (os_type_ == &::google::protobuf::internal::kEmptyString) {
    os_type_ = new ::std::string;
  }
  return os_type_;
}
inline ::std::string* UserAgent::release_os_type() {
  clear_has_os_type();
  if (os_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = os_type_;
    os_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserAgent::set_allocated_os_type(::std::string* os_type) {
  if (os_type_ != &::google::protobuf::internal::kEmptyString) {
    delete os_type_;
  }
  if (os_type) {
    set_has_os_type();
    os_type_ = os_type;
  } else {
    clear_has_os_type();
    os_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string os_ver = 2;
inline bool UserAgent::has_os_ver() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserAgent::set_has_os_ver() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserAgent::clear_has_os_ver() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserAgent::clear_os_ver() {
  if (os_ver_ != &::google::protobuf::internal::kEmptyString) {
    os_ver_->clear();
  }
  clear_has_os_ver();
}
inline const ::std::string& UserAgent::os_ver() const {
  return *os_ver_;
}
inline void UserAgent::set_os_ver(const ::std::string& value) {
  set_has_os_ver();
  if (os_ver_ == &::google::protobuf::internal::kEmptyString) {
    os_ver_ = new ::std::string;
  }
  os_ver_->assign(value);
}
inline void UserAgent::set_os_ver(const char* value) {
  set_has_os_ver();
  if (os_ver_ == &::google::protobuf::internal::kEmptyString) {
    os_ver_ = new ::std::string;
  }
  os_ver_->assign(value);
}
inline void UserAgent::set_os_ver(const char* value, size_t size) {
  set_has_os_ver();
  if (os_ver_ == &::google::protobuf::internal::kEmptyString) {
    os_ver_ = new ::std::string;
  }
  os_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserAgent::mutable_os_ver() {
  set_has_os_ver();
  if (os_ver_ == &::google::protobuf::internal::kEmptyString) {
    os_ver_ = new ::std::string;
  }
  return os_ver_;
}
inline ::std::string* UserAgent::release_os_ver() {
  clear_has_os_ver();
  if (os_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = os_ver_;
    os_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserAgent::set_allocated_os_ver(::std::string* os_ver) {
  if (os_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete os_ver_;
  }
  if (os_ver) {
    set_has_os_ver();
    os_ver_ = os_ver;
  } else {
    clear_has_os_ver();
    os_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string model = 3;
inline bool UserAgent::has_model() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserAgent::set_has_model() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserAgent::clear_has_model() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserAgent::clear_model() {
  if (model_ != &::google::protobuf::internal::kEmptyString) {
    model_->clear();
  }
  clear_has_model();
}
inline const ::std::string& UserAgent::model() const {
  return *model_;
}
inline void UserAgent::set_model(const ::std::string& value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(value);
}
inline void UserAgent::set_model(const char* value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(value);
}
inline void UserAgent::set_model(const char* value, size_t size) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserAgent::mutable_model() {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  return model_;
}
inline ::std::string* UserAgent::release_model() {
  clear_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = model_;
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserAgent::set_allocated_model(::std::string* model) {
  if (model_ != &::google::protobuf::internal::kEmptyString) {
    delete model_;
  }
  if (model) {
    set_has_model();
    model_ = model;
  } else {
    clear_has_model();
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string client_ver = 4;
inline bool UserAgent::has_client_ver() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserAgent::set_has_client_ver() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserAgent::clear_has_client_ver() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserAgent::clear_client_ver() {
  if (client_ver_ != &::google::protobuf::internal::kEmptyString) {
    client_ver_->clear();
  }
  clear_has_client_ver();
}
inline const ::std::string& UserAgent::client_ver() const {
  return *client_ver_;
}
inline void UserAgent::set_client_ver(const ::std::string& value) {
  set_has_client_ver();
  if (client_ver_ == &::google::protobuf::internal::kEmptyString) {
    client_ver_ = new ::std::string;
  }
  client_ver_->assign(value);
}
inline void UserAgent::set_client_ver(const char* value) {
  set_has_client_ver();
  if (client_ver_ == &::google::protobuf::internal::kEmptyString) {
    client_ver_ = new ::std::string;
  }
  client_ver_->assign(value);
}
inline void UserAgent::set_client_ver(const char* value, size_t size) {
  set_has_client_ver();
  if (client_ver_ == &::google::protobuf::internal::kEmptyString) {
    client_ver_ = new ::std::string;
  }
  client_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserAgent::mutable_client_ver() {
  set_has_client_ver();
  if (client_ver_ == &::google::protobuf::internal::kEmptyString) {
    client_ver_ = new ::std::string;
  }
  return client_ver_;
}
inline ::std::string* UserAgent::release_client_ver() {
  clear_has_client_ver();
  if (client_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = client_ver_;
    client_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserAgent::set_allocated_client_ver(::std::string* client_ver) {
  if (client_ver_ != &::google::protobuf::internal::kEmptyString) {
    delete client_ver_;
  }
  if (client_ver) {
    set_has_client_ver();
    client_ver_ = client_ver;
  } else {
    clear_has_client_ver();
    client_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string network = 5;
inline bool UserAgent::has_network() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserAgent::set_has_network() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserAgent::clear_has_network() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserAgent::clear_network() {
  if (network_ != &::google::protobuf::internal::kEmptyString) {
    network_->clear();
  }
  clear_has_network();
}
inline const ::std::string& UserAgent::network() const {
  return *network_;
}
inline void UserAgent::set_network(const ::std::string& value) {
  set_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    network_ = new ::std::string;
  }
  network_->assign(value);
}
inline void UserAgent::set_network(const char* value) {
  set_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    network_ = new ::std::string;
  }
  network_->assign(value);
}
inline void UserAgent::set_network(const char* value, size_t size) {
  set_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    network_ = new ::std::string;
  }
  network_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserAgent::mutable_network() {
  set_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    network_ = new ::std::string;
  }
  return network_;
}
inline ::std::string* UserAgent::release_network() {
  clear_has_network();
  if (network_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = network_;
    network_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserAgent::set_allocated_network(::std::string* network) {
  if (network_ != &::google::protobuf::internal::kEmptyString) {
    delete network_;
  }
  if (network) {
    set_has_network();
    network_ = network;
  } else {
    clear_has_network();
    network_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string location = 6;
inline bool UserAgent::has_location() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserAgent::set_has_location() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserAgent::clear_has_location() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserAgent::clear_location() {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    location_->clear();
  }
  clear_has_location();
}
inline const ::std::string& UserAgent::location() const {
  return *location_;
}
inline void UserAgent::set_location(const ::std::string& value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void UserAgent::set_location(const char* value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void UserAgent::set_location(const char* value, size_t size) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserAgent::mutable_location() {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  return location_;
}
inline ::std::string* UserAgent::release_location() {
  clear_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = location_;
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserAgent::set_allocated_location(::std::string* location) {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    delete location_;
  }
  if (location) {
    set_has_location();
    location_ = location;
  } else {
    clear_has_location();
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string carrier_operator = 7;
inline bool UserAgent::has_carrier_operator() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserAgent::set_has_carrier_operator() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserAgent::clear_has_carrier_operator() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserAgent::clear_carrier_operator() {
  if (carrier_operator_ != &::google::protobuf::internal::kEmptyString) {
    carrier_operator_->clear();
  }
  clear_has_carrier_operator();
}
inline const ::std::string& UserAgent::carrier_operator() const {
  return *carrier_operator_;
}
inline void UserAgent::set_carrier_operator(const ::std::string& value) {
  set_has_carrier_operator();
  if (carrier_operator_ == &::google::protobuf::internal::kEmptyString) {
    carrier_operator_ = new ::std::string;
  }
  carrier_operator_->assign(value);
}
inline void UserAgent::set_carrier_operator(const char* value) {
  set_has_carrier_operator();
  if (carrier_operator_ == &::google::protobuf::internal::kEmptyString) {
    carrier_operator_ = new ::std::string;
  }
  carrier_operator_->assign(value);
}
inline void UserAgent::set_carrier_operator(const char* value, size_t size) {
  set_has_carrier_operator();
  if (carrier_operator_ == &::google::protobuf::internal::kEmptyString) {
    carrier_operator_ = new ::std::string;
  }
  carrier_operator_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserAgent::mutable_carrier_operator() {
  set_has_carrier_operator();
  if (carrier_operator_ == &::google::protobuf::internal::kEmptyString) {
    carrier_operator_ = new ::std::string;
  }
  return carrier_operator_;
}
inline ::std::string* UserAgent::release_carrier_operator() {
  clear_has_carrier_operator();
  if (carrier_operator_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = carrier_operator_;
    carrier_operator_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserAgent::set_allocated_carrier_operator(::std::string* carrier_operator) {
  if (carrier_operator_ != &::google::protobuf::internal::kEmptyString) {
    delete carrier_operator_;
  }
  if (carrier_operator) {
    set_has_carrier_operator();
    carrier_operator_ = carrier_operator;
  } else {
    clear_has_carrier_operator();
    carrier_operator_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Header

// required .DdKd.KDMsgType type = 1;
inline bool Header::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Header::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Header::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Header::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::DdKd::KDMsgType Header::type() const {
  return static_cast< ::DdKd::KDMsgType >(type_);
}
inline void Header::set_type(::DdKd::KDMsgType value) {
  assert(::DdKd::KDMsgType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional uint64 msg_id = 2;
inline bool Header::has_msg_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Header::set_has_msg_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Header::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Header::clear_msg_id() {
  msg_id_ = GOOGLE_ULONGLONG(0);
  clear_has_msg_id();
}
inline ::google::protobuf::uint64 Header::msg_id() const {
  return msg_id_;
}
inline void Header::set_msg_id(::google::protobuf::uint64 value) {
  set_has_msg_id();
  msg_id_ = value;
}

// optional uint64 auth_user_id = 3;
inline bool Header::has_auth_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Header::set_has_auth_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Header::clear_has_auth_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Header::clear_auth_user_id() {
  auth_user_id_ = GOOGLE_ULONGLONG(0);
  clear_has_auth_user_id();
}
inline ::google::protobuf::uint64 Header::auth_user_id() const {
  return auth_user_id_;
}
inline void Header::set_auth_user_id(::google::protobuf::uint64 value) {
  set_has_auth_user_id();
  auth_user_id_ = value;
}

// optional bytes log_id = 4;
inline bool Header::has_log_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Header::set_has_log_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Header::clear_has_log_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Header::clear_log_id() {
  if (log_id_ != &::google::protobuf::internal::kEmptyString) {
    log_id_->clear();
  }
  clear_has_log_id();
}
inline const ::std::string& Header::log_id() const {
  return *log_id_;
}
inline void Header::set_log_id(const ::std::string& value) {
  set_has_log_id();
  if (log_id_ == &::google::protobuf::internal::kEmptyString) {
    log_id_ = new ::std::string;
  }
  log_id_->assign(value);
}
inline void Header::set_log_id(const char* value) {
  set_has_log_id();
  if (log_id_ == &::google::protobuf::internal::kEmptyString) {
    log_id_ = new ::std::string;
  }
  log_id_->assign(value);
}
inline void Header::set_log_id(const void* value, size_t size) {
  set_has_log_id();
  if (log_id_ == &::google::protobuf::internal::kEmptyString) {
    log_id_ = new ::std::string;
  }
  log_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Header::mutable_log_id() {
  set_has_log_id();
  if (log_id_ == &::google::protobuf::internal::kEmptyString) {
    log_id_ = new ::std::string;
  }
  return log_id_;
}
inline ::std::string* Header::release_log_id() {
  clear_has_log_id();
  if (log_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = log_id_;
    log_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Header::set_allocated_log_id(::std::string* log_id) {
  if (log_id_ != &::google::protobuf::internal::kEmptyString) {
    delete log_id_;
  }
  if (log_id) {
    set_has_log_id();
    log_id_ = log_id;
  } else {
    clear_has_log_id();
    log_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .DdKd.UserAgent user_agent = 5;
inline bool Header::has_user_agent() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Header::set_has_user_agent() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Header::clear_has_user_agent() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Header::clear_user_agent() {
  if (user_agent_ != NULL) user_agent_->::DdKd::UserAgent::Clear();
  clear_has_user_agent();
}
inline const ::DdKd::UserAgent& Header::user_agent() const {
  return user_agent_ != NULL ? *user_agent_ : *default_instance_->user_agent_;
}
inline ::DdKd::UserAgent* Header::mutable_user_agent() {
  set_has_user_agent();
  if (user_agent_ == NULL) user_agent_ = new ::DdKd::UserAgent;
  return user_agent_;
}
inline ::DdKd::UserAgent* Header::release_user_agent() {
  clear_has_user_agent();
  ::DdKd::UserAgent* temp = user_agent_;
  user_agent_ = NULL;
  return temp;
}
inline void Header::set_allocated_user_agent(::DdKd::UserAgent* user_agent) {
  delete user_agent_;
  user_agent_ = user_agent;
  if (user_agent) {
    set_has_user_agent();
  } else {
    clear_has_user_agent();
  }
}

// -------------------------------------------------------------------

// KDLocationInfo

// required uint64 driverid = 1;
inline bool KDLocationInfo::has_driverid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KDLocationInfo::set_has_driverid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KDLocationInfo::clear_has_driverid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KDLocationInfo::clear_driverid() {
  driverid_ = GOOGLE_ULONGLONG(0);
  clear_has_driverid();
}
inline ::google::protobuf::uint64 KDLocationInfo::driverid() const {
  return driverid_;
}
inline void KDLocationInfo::set_driverid(::google::protobuf::uint64 value) {
  set_has_driverid();
  driverid_ = value;
}

// required double lat = 2;
inline bool KDLocationInfo::has_lat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KDLocationInfo::set_has_lat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KDLocationInfo::clear_has_lat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KDLocationInfo::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline double KDLocationInfo::lat() const {
  return lat_;
}
inline void KDLocationInfo::set_lat(double value) {
  set_has_lat();
  lat_ = value;
}

// required double lng = 3;
inline bool KDLocationInfo::has_lng() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KDLocationInfo::set_has_lng() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KDLocationInfo::clear_has_lng() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KDLocationInfo::clear_lng() {
  lng_ = 0;
  clear_has_lng();
}
inline double KDLocationInfo::lng() const {
  return lng_;
}
inline void KDLocationInfo::set_lng(double value) {
  set_has_lng();
  lng_ = value;
}

// required double spd = 4;
inline bool KDLocationInfo::has_spd() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KDLocationInfo::set_has_spd() {
  _has_bits_[0] |= 0x00000008u;
}
inline void KDLocationInfo::clear_has_spd() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void KDLocationInfo::clear_spd() {
  spd_ = 0;
  clear_has_spd();
}
inline double KDLocationInfo::spd() const {
  return spd_;
}
inline void KDLocationInfo::set_spd(double value) {
  set_has_spd();
  spd_ = value;
}

// required .DdKd.KDLocationInfo.WorkState work = 5;
inline bool KDLocationInfo::has_work() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void KDLocationInfo::set_has_work() {
  _has_bits_[0] |= 0x00000010u;
}
inline void KDLocationInfo::clear_has_work() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void KDLocationInfo::clear_work() {
  work_ = 1;
  clear_has_work();
}
inline ::DdKd::KDLocationInfo_WorkState KDLocationInfo::work() const {
  return static_cast< ::DdKd::KDLocationInfo_WorkState >(work_);
}
inline void KDLocationInfo::set_work(::DdKd::KDLocationInfo_WorkState value) {
  assert(::DdKd::KDLocationInfo_WorkState_IsValid(value));
  set_has_work();
  work_ = value;
}

// required uint64 location_timestamp = 6;
inline bool KDLocationInfo::has_location_timestamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void KDLocationInfo::set_has_location_timestamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void KDLocationInfo::clear_has_location_timestamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void KDLocationInfo::clear_location_timestamp() {
  location_timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_location_timestamp();
}
inline ::google::protobuf::uint64 KDLocationInfo::location_timestamp() const {
  return location_timestamp_;
}
inline void KDLocationInfo::set_location_timestamp(::google::protobuf::uint64 value) {
  set_has_location_timestamp();
  location_timestamp_ = value;
}

// required uint32 location_type = 7;
inline bool KDLocationInfo::has_location_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void KDLocationInfo::set_has_location_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void KDLocationInfo::clear_has_location_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void KDLocationInfo::clear_location_type() {
  location_type_ = 0u;
  clear_has_location_type();
}
inline ::google::protobuf::uint32 KDLocationInfo::location_type() const {
  return location_type_;
}
inline void KDLocationInfo::set_location_type(::google::protobuf::uint32 value) {
  set_has_location_type();
  location_type_ = value;
}

// required double direction = 8;
inline bool KDLocationInfo::has_direction() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void KDLocationInfo::set_has_direction() {
  _has_bits_[0] |= 0x00000080u;
}
inline void KDLocationInfo::clear_has_direction() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void KDLocationInfo::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline double KDLocationInfo::direction() const {
  return direction_;
}
inline void KDLocationInfo::set_direction(double value) {
  set_has_direction();
  direction_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace DdKd

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DdKd::KDLocationInfo_WorkState>() {
  return ::DdKd::KDLocationInfo_WorkState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DdKd::Constants>() {
  return ::DdKd::Constants_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DdKd::KDMsgType>() {
  return ::DdKd::KDMsgType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_kd_5fdd_5fprotocol_2eproto__INCLUDED
